// use::std;

#[derive(Clone, PartialEq, Debug)]
pub enum TokenType {
    Eof(usize),
    VarPrefix(usize),
    LeftBracket(usize),
    RightBracket(usize),
    Equal(usize),
    String(usize, String),
    Name(usize, String),
    Print(usize),
    Ignored(usize),
    None,
}

#[derive(Clone, Debug)]
pub struct Token {
    token_type: TokenType,
    line: usize,
    string: Option<String>,
}

pub struct Lexer {
    source: Vec<String>,
    line: usize,
    ptr: usize,
    nextTokenInfo: TokenType,
    nextTokenLine: usize,
}

impl Lexer {
    pub fn new(source: String) -> Self {
        Lexer {
            source: source.split('\n').map(|s| s.to_string()).collect(),
            line: 0,
            ptr: 0,
            nextTokenInfo: TokenType::None,
            nextTokenLine: 0,
        }
    }

    pub fn print(&self) {
        println!("{:?}", self.source);
    }

    fn scan_name(&self, s: &str, start: usize) -> (usize, String) {
        let codes = &s[start..];
        let mut i = 0;
        for c in codes.chars() {
            match c {
                '_' | 'a'..='z' | 'A'..='Z' | '0'..='9' => i += 1,
                _ => break,
            }
        }
        (i, codes[..i].to_string())
    }

    fn scan_string(&self, s: &str, start: usize) -> (usize, String) {
        let codes = &s[start..];
        let mut i = 0;
        for c in codes.chars() {
            match c {
                '"' => {
                    i += 1;
                    return (i, codes[..i - 1].to_string());
                }
                _ => i += 1,
            }
        }
        panic!("scan_string: \" not matched!");
    }

    pub fn get_next_token(&mut self) -> TokenType {
        if self.nextTokenInfo != TokenType::None {
            let token_info = self.nextTokenInfo.clone();
            self.nextTokenInfo = TokenType::None;
            return token_info;
        }

        if self.ptr >= self.source[self.line].len() {
            self.line += 1;
            while self.source[self.line].is_empty() {
                self.line += 1;
                if self.line >= self.source.len() {
                    return TokenType::Eof(self.line);
                }
            }
            self.ptr = 0;
        }

        // println!(
        //     "### {} {} {} {}",
        //     self.line,
        //     self.ptr,
        //     self.source[self.line].len(),
        //     self.source.len()
        // );
        let mut current_line = self.source[self.line][self.ptr..].chars();
        self.ptr += 1;
        let c = current_line.next().unwrap();
        match c {
            '$' => return TokenType::VarPrefix(self.line),

            '(' => return TokenType::LeftBracket(self.line),

            ')' => return TokenType::RightBracket(self.line),

            '=' => return TokenType::Equal(self.line),
            '"' => {
                let (i, s) = self.scan_string(&self.source[self.line], self.ptr);
                self.ptr += i;
                // println!("in string: {} {} {}", i, s, self.ptr);
                return TokenType::String(self.line, s);
            }
            '_' | 'A'..='z' => {
                let (i, s) = self.scan_name(&self.source[self.line], self.ptr - 1);
                // println!("in Name: {} {}", i, s);
                self.ptr += i - 1;
                return TokenType::Name(self.line, s);
            }
            ' ' | '\n' | '\r' | '\t' => return TokenType::Ignored(self.line),
            _ => panic!(
                "MatchToken(): unexpected symbol {} {}:{} | {}",
                c,
                self.line,
                self.ptr,
                self.source[self.line].len()
            ),
        }
    }

    pub fn next_token_is(&mut self, token_type: TokenType) -> TokenType {
        let now_type = self.get_next_token();
        if token_type != now_type {
            panic!("NextTokenIs(): syntax error");
        }
        now_type
    }

    pub fn lookahead(&mut self) -> TokenType {
        match self.nextTokenInfo {
            TokenType::None => self.nextTokenInfo = self.get_next_token(),
            _ => {}
        }
        self.nextTokenInfo.clone()
    }
}
